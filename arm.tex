\documentclass[main.tex]{subfiles}
\begin{document}
\chapter{ARM}
\section{Introduzione ai micro ARM e CORTEX}
\subsection{Configurazione del micro}

\section{Seriale}
L'esperienza della seriale è del tutto analoga a quella con l'8051, il programma è diviso in 3 fasi:\begin{enumerate}
    \item Nella prima fase si trasmette un messaggio di benvenuto al computer
    \item Nella seconda fase il micro entra in modalità eco, ritrasmettendo indietro tutti i caratteri che gli si mandano
    \item Infine riceve una serie di caratteri memorizzandoli e poi rimandando il messaggio ricevuto
\end{enumerate}
Per la USART è stata usata la USART2 del micro abilitandola dal STM32Cube e se ne è abilitato l'interrupt nel NVIC(Nested Vector Interrupt Controller), questo perché la USART2 è già implementata nell'STLink quindi la comunicazione avviene tramite il cavo mini-USB. 

Un'ulteriore differenza con l'8051 è che il buffer per la trasmissione e per la ricezione sono distinti(il che probabilmente rende più chiaro anche il codice) e sono rispettivamente \textit{TDR} e \textit{RDR}. 

Si è creato un file\_condiviso.h come header sia per il file main.c sia per il file che gestisce gli interrupt(stm32f0xx\_it.c). Esso contiene alcune definizioni importanti per entrambi i codici e permette il dialogo tra i due file, come ad esempio \textit{puntatore} che viene usata da entrambi.
\begin{lstlisting}[language=C,caption=Header dei files]
#define CR 13
#define LF 10
#define ML 10
extern unsigned char * puntatore;
extern unsigned char msg_ricevuto[ML+4];
extern int lenght_da_trasmettere;
extern unsigned char  messaggio_benvenuto[7];
extern int lenght;
extern unsigned char msg_errore[10];
extern int lenght_errore;
extern int status;
extern int i;
extern int loaded;
\end{lstlisting}
Quelle riportate di seguito sono le inizializzazioni delle variabili precedenti nel main.
\begin{lstlisting}[language=c,caption=Inizializzazione variabili]
unsigned char * puntatore;
unsigned char msg_ricevuto[ML+4];
int lenght_da_trasmettere=6;
unsigned char messaggio_benvenuto[]={'C','i','a'
,'o',CR,LF};
unsigned char;
msg_errore[]={CR,LF,'E','r','r','o','r','e',CR,LF};
int lenght_errore=10;
int status = 0;
int loaded =0;
int i=0;
\end{lstlisting}

Il vero codice inizia dopo che è avvenuta la configurazione del micro, abilitando l'interrupt di trasmissione e ricezione della USART2. Successivamente si passa il primo carattere da trasmettere al registro TDR.\footnote{È necessario fare il reset del bit di transmission completed perché quando vengono abilitati gli interrupt il micro entra in interrupt e se questo bit fosse 1 lo interpreterebbe come primo carattere trasmesso}
\begin{lstlisting}[language=C,caption=main]
//reset del interrupt control register
//al bit trasmission completed
USART2->ICR |= USART_ICR_TCCF;
//abilito l'interrupt per la trasmissione
USART2->CR1 |= USART_CR1_TCIE;
//abilito l'interrupt per la ricezione
USART2->CR1 |= USART_CR1_RXNEIE;
//inizio a trasmettere il messaggio di benvenuto
msg_ricevuto[0]=CR;
msg_ricevuto[1]=LF;
puntatore= messaggio_benvenuto;
USART2->TDR=*puntatore;
\end{lstlisting}
Quando il micro finisce di trasmettere entra nell'interrupt con il bit di TC ad 1, a questo punto è necessario fare qualcosa e sarà la funzione scelta a determinare cosa.
\begin{lstlisting}[language=C, caption=gestione dell'interrupt]
if((USART2->ISR & USART_ISR_TC) == USART_ISR_TC){
	//resetto il flag di trasmissione completata
	USART2->ICR |= USART_ICR_TCCF;
	//allora ho appena finito di trasmettere
	scelta();
	loaded=0;
	return;
	}
else if((USART2->ISR&USART_ISR_RXNE)==USART_ISR_RXNE){
	//allora ho appena finito di ricevere
	scelta();
	return;
	}
\end{lstlisting}

La funzione scelta è il cuore di questo programma. È l'evoluzione della stessa implementata per la seriale in C \ref{lst:scelta}.
\begin{lstlisting}[language=C,caption=Funzione scelta]
void scelta(){
	unsigned char carattere;
	switch(status){
		case 0:
			//inserisco nel buffer di trasm il carattere
			i++;
			if(i<lenght_da_trasmettere){
				USART2->TDR=*(puntatore+i);
			}
			else{
				status=1;
				i=0;
			}
			break;
		case 1:
			//do
				//inserisco nel buffer di trasmissione
				//il carattere trovato nel buffer in ricezione
				carattere = (char)USART2->RDR;
				if(carattere=='#'){
					i=2;
					status=2;
				}
				else{
				if(!loaded){
					loaded=1;
					USART2->TDR=carattere;
				}
			}
			break;
		case 2:
			//do
				
				carattere=USART2->RDR;
				if(i<ML+3){
					//aggiungo il carattere letto al vettore
					msg_ricevuto[i]=carattere;
					i++;
					if(carattere=='#'){
						//smetto di ricevere
						status=0;
						puntatore=msg_ricevuto;
						msg_ricevuto[i-1]=CR;
						msg_ricevuto[i]=LF;
						lenght_da_trasmettere=i+1;
						i=0;
						//trasmetto il messaggio ricevuto
						USART2->TDR=*puntatore;
					}
				}
				else{
					status=0;
					//trasmetto il messaggio di errore
					puntatore=msg_errore;
					lenght_da_trasmettere=lenght_errore;
					i=0;
					USART2->TDR=*puntatore;
				}
			
			break;
	}
}
\end{lstlisting}
\section{Timer7 e Led}
Questa esperienza è analoga a quella svolta con il led ed il bottone per l'8051 in C(referenza:\ref{led in C}). Infatti l'obiettivo è di realizzare un programma in cui si possa cambiare la luminosità del LED sfruttando gli interrupt del timer del micro ed il bottone. Dunque è stato configurato il Timer 7(TIM7) a 16 bit e l'overflow a 10000(quindi il timer conta da 0 a 10000), con il relativo interrupt. Abbiamo abilitato la porta PA5 come GPIO output per poter accendere e spegnere il led, ed è stato abilitato l'interrupt esterno della porta PC13(il bottone), di modo che ogni volta che viene premuto, viene generato un interrupt.

La funzione wait\_tim aspetta che il timer abbia raggiunto n interrupt, facendo trascorrere un po' di tempo.
\begin{lstlisting}[language=C, caption=Funzione wait\_tim per aspettare]
void wait_tim(){
	wait=1;
	TIM7->CNT=0;//si imposta il contatore a 0
	TIM7->SR=0;//si imposta lo status register a 0
	//si abilita il counter per iniziare a contare
	TIM7->CR1|=TIM_CR1_CEN;
	//si aspetta fino a che non viene settata a 0
	while(wait){}
}
\end{lstlisting}
All'interno dell'interrupt del timer è necessario fare un check sulla variabile \textit{loop}, la quale indica quanti cicli di interrupt bisogna attendere prima di fermare il timer.  
\begin{lstlisting}[language=C, caption=Gestione dell'interrupt del timer]
if(loops>0){
		loops-=1;
		TIM7->CR1|=TIM_CR1_CEN;
	}
else{
	wait=0;//si puo smettere di aspettare
	//e smettere di contare
	TIM7->CR1&=~TIM_CR1_CEN;
}
\end{lstlisting}

All'interno dell'interrupt del bottone è necessario cambiare la luminosità, questo come nel caso della luminosità in C\ref{lst:led in C}, viene fatto cambiando il numero di loop che il led sta accesso ovvero la variabile \textit{loop\_on}. Come nel caso del C, la variabile status indica 5 possibili luminosità(0,25,50,75,100), ciclando su di essi.
\begin{lstlisting}[language=C, caption=Gestione interrupt del bottone]
if(status<4){
	status++;
}
else{
	status=0;
}
loops_on=n_loops*status*25/100;//cambio la luminosita'
//resetto
wait=0;
acceso=0;
\end{lstlisting}

\begin{lstlisting}[language=C, caption=Variabili globali interrupt]
int status=0;
int loops_on=0;
int n_loops=50;
int acceso;
int wait;
volatile int loops=0;
\end{lstlisting}

\begin{lstlisting}[language=C,caption=Variabili globali main]
extern int loops_on;
extern int n_loops;
extern int acceso;
extern int wait;
extern int loops;
\end{lstlisting}
All'interno del main è necessario innanzitutto abilitare l'interrupt del timer, successivamente si entra in un loop infinito all'interno del quale si continua ad accendere e spegnere il led. Il led rimane acceso per \textit{loops\_on} cicli e spento per \textit{n\_loops-loops\_on} cicli, con \textit{n\_loops} il numero massimo di cicli. 

\begin{lstlisting}[language=C,caption=Main]
//abilito l'interrupt del timer
TIM7->DIER|=TIM_DIER_UIE;
while (1)
  {
	if(acceso==0){
		//accendo
		//cambio lo stato del led
		HAL_GPIO_TogglePin(GPIOA,GPIO_PIN_5);
		//devo aspettare loops_on cicli
		loops=loops_on;
		wait_tim();
		acceso=1;
	}
	else{
		//spengo
		HAL_GPIO_TogglePin(GPIOA,GPIO_PIN_5);
		//devo aspettare loops massimi - loops_on
		loops=n_loops-loops_on;
		wait_tim();
		acceso=0;
	}
}
\end{lstlisting}
\section{I2C, termometro e display}
\end{document}